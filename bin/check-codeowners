#!/usr/bin/env ruby

require 'optparse'
require 'set'
require 'shellwords'
require 'tempfile'

CODEOWNERS_PATH = ".github/CODEOWNERS"
CODEOWNERS_IGNORE_PATH = ".github/CODEOWNERS.ignore"
VALIDOWNERS_PATH = ".github/VALIDOWNERS"

class Entry
  def initialize(text:, file:, line_number:)
    @text = text
    @file = file
    @line_number = line_number
  end

  attr_reader :text, :file, :line_number

  def to_json(*args)
    to_h.to_json(*args)
  end

  def to_h
    { text: text, file: file, line_number: line_number }
  end
end

class OwnerEntry < Entry
  def initialize(text:, file:, line_number:, pattern:, owners:, indent:)
    super(text: text, file: file, line_number: line_number)
    @pattern = pattern
    @owners = owners
    @indent = indent
  end

  attr_reader :pattern, :owners, :indent

  def to_h
    super.merge(pattern: pattern, owners: owners, indent: indent)
  end
end

def parse_codeowners_file
  lines = begin
            IO.readlines(CODEOWNERS_PATH).map(&:chomp)
          rescue Errno::ENOENT
            []
          end

  owner_re = /\S+/

  errors = []

  entries = lines.each_with_index.map do |line, index|
    base = { line_number: index + 1, text: line, file: CODEOWNERS_PATH }

    case line
    when "", /^#/
      # Could be used in the future to reconstruct the file
      Entry.new(base)
    when /^((\S+)\s+)(#{owner_re}( #{owner_re})*)$/
      base.merge!(pattern: $2, indent: ($1).length, owners: $3.split(' '))
      OwnerEntry.new(base)
    else
      Entry.new(base).tap do |entry|
        errors << {
          code: "unrecognised_line",
          message: "Unrecognised line at #{entry.file}:#{entry.line_number}",
          entry: entry
        }
      end
    end
  end

  Struct.new(:entries, :errors).new(entries, errors)
end

def parse_unownedignore_file
  lines = begin
            IO.readlines(CODEOWNERS_IGNORE_PATH).map(&:chomp)
          rescue Errno::ENOENT
            []
          end

  patterns = Set.new
  files = Set.new
  previous_line = nil

  errors = []

  lines.each_with_index do |line, index|
    next if line.empty? || line.start_with?("#")

    if previous_line && line <= previous_line
      errors << {
        message: "Line is duplicated or out of sequence at #{CODEOWNERS_IGNORE_PATH}:#{index + 1}",
        code: "ignore_file_not_in_sequence",
        file: CODEOWNERS_IGNORE_PATH,
        line: index + 1,
      }
    end

    previous_line = line

    if line.include?("*")
      patterns << line
    else
      files << line
    end
  end

  Struct.new(:patterns, :files, :errors).new(patterns, files, errors)
end

def warn(item)
  @warnings << item
end

def error(item)
  @errors << item
end

def check_sorted(owner_entries)
  # We could auto-fix this, if it wasn't for comments and blank lines
  owner_entries.each_with_index.select do |entry, index|
    if index > 0 && entry.pattern <= owner_entries[index - 1].pattern
      error(
        code: "codeowners_file_not_in_sequence",
        message: "Line is duplicated or out of sequence at #{entry.file}:#{entry.line_number}",
        entry: entry
      )
    end
  end
end

def check_indent(owner_entries)
  errors = []

  # We could auto-fix this
  owner_entries.each_with_index.select do |entry, index|
    if index > 0 && entry.indent != owner_entries[index - 1].indent
      errors << {
        code: "mismatched_indent",
        message: "Mismatched indent at #{entry.file}:#{entry.line_number}",
        entry: entry
      }
    end
  end

  Struct.new(:errors).new(errors)
end

def check_valid_owners(owner_entries)
  # This is just to catch typos.
  # We could look up against github, of course.
  # For now, hard-wired is better than nothing.
  valid_owners = begin
                   IO.readlines(VALIDOWNERS_PATH).map(&:chomp)
                 rescue Errno::ENOENT
                   nil
                 end

  errors = []

  if valid_owners
    owner_entries.each do |entry|
      bad_owners = entry.owners - valid_owners

      bad_owners.each do |bad_owner|
        errors << {
          code: "invalid_owner",
          message: "Invalid owner #{bad_owner} at #{entry.file}:#{entry.line_number}",
          bad_owner: bad_owner,
          entry: entry
        }
      end
    end
  end

  Struct.new(:errors).new(errors)
end

def git_ls_files(args:)
  output = `git ls-files -z #{Shellwords.shelljoin(args)}`
  $?.success? or raise "git ls-files #{args.inspect} failed"

  output.split("\0")
end

def get_all_files
  git_ls_files(args: [])
end

def find_unowned_files(owner_entries, all_files)
  all_owners = owner_entries.map(&:owners).flatten.uniq

  unowned_files = Set.new(all_files)

  all_owners.each do |owner|
    Tempfile.open do |tmpfile|
      owner_entries.each do |entry|
        if entry.owners.include?(owner)
          tmpfile.puts entry.pattern
        end
      end

      tmpfile.flush

      owned_files = git_ls_files(args: ["--cached", "--ignored", "--exclude-from", tmpfile.path])
      unowned_files -= owned_files
    end
  end

  # Report on any file which is not matched by any entry (unowned)
  unowned_files.sort
end

def check_individual_patterns(owner_entries)
  # Slow but thorough: use git to check which files each individual pattern matches
  # May not scale well!

  match_map = {}

  owner_entries.each do |entry|
    matched_files = git_ls_files(args: ["--cached", "--ignored", "--exclude", entry.pattern])

    # Report on any pattern which doesn't match any files (cruft)
    if matched_files.empty?
      warn(
        code: "unmatched_pattern",
        message: "Pattern #{entry.pattern} at #{entry.file}:#{entry.line_number} doesn't match any files",
        entry: entry,
      )
    end

    matched_files.each do |file|
      (match_map[file] ||= []) << entry
    end
  end

  # Should we report on any file matched by more than one entry?
  # It could indicate an unintended conflict. But what if the
  # "conflict" is absolutely intended? Maybe it's not worth checking.
  # Maybe "too many" owners is better than too few.

  match_map
end

def report_file_ownership(results, show_json, json_root_key)
  if show_json
    require 'json'
    puts JSON.pretty_generate(json_root_key => results)
  else
    results.each do |result|
      if result[:owners].any?
        puts "#{result[:file]}\t#{result[:owners].join(' ')}"
      else
        puts "#{result[:file]}\t-"
      end
    end
  end
end

def report_who_owns(owner_entries, show_json, files)
  match_map = check_individual_patterns(owner_entries)

  results = files.map do |file|
    file = file.sub(/^\.\/+/, '')
    matches = match_map[file]
    owners = if matches
      matches.map(&:owners).flatten.sort.uniq
    end
    { file: file, owners: owners || [] }
  end

  report_file_ownership(results, show_json, :who_owns)
end

def report_files_owned(owner_entries, show_json, args)
  # We don't *have* to brute force every pattern - we could instead
  # run git ls-files per owner, not per pattern. But we already have
  # the code, so it's convenient.
  match_map = if args.any?
    check_individual_patterns(owner_entries)
  else
    {}
  end

  results = get_all_files.map do |file|
    matches = match_map[file]
    next unless matches

    owners = matches.map(&:owners).flatten.sort.uniq & args
    next unless owners.any?

    { file: file, owners: owners }
  end.compact

  report_file_ownership(results, show_json, :files_owned)
end

# Warns if there are entries in the ignore file that are now owned
# Errors if there are files that don't have an owner (except if the file is included in ignore)
def check_unowned_files(unowned_files)
  unowned_files = Set.new(unowned_files)

  parsed = parse_unownedignore_file

  warnings = []
  errors = [*parsed.errors]
  used_ignores = Set.new
  ignored_unowned = Set.new

  unowned_files.each do |unowned_file|
    if parsed.files.include?(unowned_file)
      ignored_unowned.add(unowned_file)
      used_ignores.add(unowned_file)
    end

    parsed.patterns.each do |ignore_pattern|
      if File.fnmatch?(ignore_pattern, unowned_file)
        ignored_unowned.add(unowned_file)
        used_ignores.add(ignore_pattern)
      end
    end
  end

  non_ignored_files = unowned_files - ignored_unowned
  non_ignored_files.sort.each do |file|
    errors << {
      code: "non_ignored_files",
      message: "Please add this file to #{CODEOWNERS_PATH}: #{file}", # This file does not have an owner
      unowned: file,
    }
  end

  unused_ignores = (parsed.files + parsed.patterns) - used_ignores
  unused_ignores.sort.each do |unused_ignore|
    warnings << {
      code: "unused_ignore",
      message: "The following entry in #{CODEOWNERS_IGNORE_PATH} doesn't match any unowned files and should be removed: #{unused_ignore}", # Obsolete entry
      unused_ignore: unused_ignore,
    }
  end

  Struct.new(:warnings, :errors).new(warnings, errors)
end

class GetOptions

  def initialize(argv)
    @debug = false
    @show_json = false
    @strict = false
    @brute_force = false
    @who_owns = false
    @files_owned = false
    @check_unowned = false
    @should_check_indent = true
    @should_check_sorted = true
    @should_check_valid_owners = true
    read_options(argv)
    validate
  end

  attr_reader :debug, :show_json, :strict, :brute_force,
    :who_owns, :files_owned,
    :check_unowned, :should_check_indent, :should_check_sorted, :should_check_valid_owners,
    :args

  private

  attr_writer :debug, :show_json, :strict, :brute_force,
    :who_owns, :files_owned,
    :check_unowned, :should_check_indent, :should_check_sorted, :should_check_valid_owners,
    :args

  def read_options(argv)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: check-codeowners [options] [arguments]"

      opts.on("-j", "--json", "Show results as JSON") do
        self.show_json = true
      end
      opts.on("-s", "--strict", "Treat warnings as errors") do
        self.strict = true
      end
      opts.on("-b", "--brute-force", "Slower, more thorough checking") do
        self.brute_force = true
      end
      opts.on("--[no-]check-indent", "Whether or not to require equal indenting") do |value|
        self.should_check_indent = value
      end
      opts.on("--[no-]check-sorted", "Whether or not to require sorted entries") do |value|
        self.should_check_sorted = value
      end
      opts.on("--[no-]check-valid-owners", "Whether or not to check owners against VALIDOWNERS") do |value|
        self.should_check_valid_owners = value
      end
      opts.on(
        "--who-owns",
        "Treat arguments as a list of files; show who owns each file, then exit." \
        " If no arguments are given, all files are shown. Incompatible with" \
        " --files-owned."
      ) do
        self.who_owns = true
      end
      opts.on(
        "--files-owned",
        "Treat arguments as a list of owners; show what files they own, then exit." \
        " Incompatible with --who-owns."
      ) do
        self.files_owned = true
      end
      opts.on(
        "--check-unowned",
        "Checks if there are new files that are not owned"
      ) do
        self.check_unowned = true
      end
      opts.on("-d", "--debug", "Include debug output; implies --json") do
        self.debug = true
        self.show_json = true
      end
    end

    argv = [*argv]
    parser.parse!(argv)
    @args = argv
  end

  def validate
    if who_owns && files_owned
      $stderr.puts "Invalid usage. Try check-codeowners --help"
      exit 2
    end

    if !who_owns && !files_owned && args.any?
      $stderr.puts "Invalid usage. Try check-codeowners --help"
      exit 2
    end
  end

end

# MAIN START

options = GetOptions.new(ARGV)

@warnings = []
@errors = []

parse_results = parse_codeowners_file
entries = parse_results.entries
parse_results.errors.each(&method(:error))
owner_entries = entries.select { |entry| entry.is_a?(OwnerEntry) }

if options.who_owns
  files = (options.args.empty? ? get_all_files : options.args)
  report_who_owns(owner_entries, options.show_json, files)
  exit
end

if options.files_owned
  report_files_owned(owner_entries, options.show_json, options.args)
  exit
end

check_sorted(owner_entries) if options.should_check_sorted

if options.should_check_indent
  r = check_indent(owner_entries)
  r.errors.each(&method(:error))
end

if options.should_check_valid_owners
  r = check_valid_owners(owner_entries)
  r.errors.each(&method(:error))
end

all_files = get_all_files
unowned = find_unowned_files(owner_entries, all_files)

if options.check_unowned
  r = check_unowned_files(unowned)
  r.warnings.each(&method(:warn))
  r.errors.each(&method(:error))
end

match_map = if options.brute_force
  check_individual_patterns(owner_entries)
end

if options.show_json
  output = {
    errors: @errors,
    warnings: @warnings
  }

  if options.debug
    output.merge!(
      entries: entries,
      owner_entries: owner_entries,
      all_files: all_files,
      match_map: match_map,
    )
  end

  require 'json'
  puts JSON.pretty_generate(output)
else
  show = proc do |prefix, item|
    output = "#{prefix}: #{item[:message]}"
    puts output
  end

  @errors.each { |item| show.call("ERROR", item) }
  @warnings.each { |item| show.call("WARNING", item) }

  if @errors.any? || @warnings.any?
    puts "For help, see https://github.com/zendesk/setup-check-codeowners/blob/main/Usage.md"
  end
end

exit 2 if @errors.any?
exit 1 if @warnings.any? && options.strict
exit 0
