#!/usr/bin/env ruby

require 'optparse'
require 'set'
require 'shellwords'
require 'tempfile'

CODEOWNERS_PATH = ".github/CODEOWNERS"
CODEOWNERS_IGNORE_PATH = ".github/CODEOWNERS.ignore"
VALIDOWNERS_PATH = ".github/VALIDOWNERS"

class MultiGitLsRunner
  PREFIX_LENGTH = 6

  def initialize(patterns)
    require 'etc'
    require 'shellwords'
    require 'tempfile'
    require 'tmpdir'

    # Each arg to the script will be "<output_file>:<pattern>"
    @inputs = patterns.sort.uniq.each_with_index.map do |pattern, index|
      [ pattern, "%0#{PREFIX_LENGTH}d" % index ]
    end
  end

  def run
    with_output_dir do
      with_splitter_script do
        run_xargs
        outputs_by_pattern
      end
    end
  end

  private

  attr_reader :inputs

  def with_output_dir
    Dir.mktmpdir do |tmpdir|
      @output_dir = tmpdir
      yield
    end
  end

  def with_splitter_script
    Tempfile.open do |script|
      script.puts <<~SCRIPT
        #!/bin/bash
        umask 077
        exec git ls-files -z --cached --ignored --exclude "${1:#{PREFIX_LENGTH + 1}}" \
          > #{Shellwords.escape(@output_dir)}/${1:0:#{PREFIX_LENGTH}}
      SCRIPT
      script.chmod 0o700
      script.close

      @splitter = script.path
      yield
    end
  end

  def run_xargs
    Tempfile.open do |input_file|
      inputs.each do |pattern, output_file|
        input_file.puts "#{output_file}:#{pattern}"
      end
      input_file.flush

      system "xargs", "-n", "1", "-P", Etc.nprocessors.to_s, @splitter,
        in: input_file.path
      $?.success? or raise "xargs / git ls-files failed"
    end
  end

  def outputs_by_pattern
    inputs.map do |pattern, output_file|
      file = File.join(@output_dir, output_file)
      results = File.read(file).split("\0")
      [pattern, results]
    end.to_h
  end
end

class Entry
  def initialize(text:, file:, line_number:)
    @text = text
    @file = file
    @line_number = line_number
  end

  attr_reader :text, :file, :line_number

  def to_json(*args)
    to_h.to_json(*args)
  end

  def to_h
    { text: text, file: file, line_number: line_number }
  end
end

class OwnerEntry < Entry
  def initialize(text:, file:, line_number:, pattern:, owners:, indent:)
    super(text: text, file: file, line_number: line_number)
    @pattern = pattern
    @owners = owners
    @indent = indent
  end

  attr_reader :pattern, :owners, :indent

  def to_h
    super.merge(pattern: pattern, owners: owners, indent: indent)
  end
end

def parse_codeowners_file
  lines = begin
            IO.readlines(CODEOWNERS_PATH).map(&:chomp)
          rescue Errno::ENOENT
            []
          end

  owner_re = /\S+/

  errors = []

  entries = lines.each_with_index.map do |line, index|
    base = { line_number: index + 1, text: line, file: CODEOWNERS_PATH }

    case line
    when "", /^#/
      # Could be used in the future to reconstruct the file
      Entry.new(base)
    when /^((\S+)\s+)(#{owner_re}( #{owner_re})*)$/
      base.merge!(pattern: $2, indent: ($1).length, owners: $3.split(' '))
      OwnerEntry.new(base)
    else
      Entry.new(base).tap do |entry|
        errors << {
          code: "unrecognised_line",
          message: "Unrecognised line at #{entry.file}:#{entry.line_number}",
          entry: entry
        }
      end
    end
  end

  Struct.new(:entries, :errors).new(entries, errors)
end

def parse_unownedignore_file(options)
  lines = begin
            IO.readlines(CODEOWNERS_IGNORE_PATH).map(&:chomp)
          rescue Errno::ENOENT
            []
          end

  patterns = Set.new
  files = Set.new
  previous_line = nil

  errors = []

  lines.each_with_index do |line, index|
    next if line.empty? || line.start_with?("#")

    if previous_line && line <= previous_line && options.should_check_sorted
      errors << {
        message: "Line is duplicated or out of sequence at #{CODEOWNERS_IGNORE_PATH}:#{index + 1}",
        code: "ignore_file_not_in_sequence",
        file: CODEOWNERS_IGNORE_PATH,
        line: index + 1,
      }
    end

    previous_line = line

    if line.include?("*")
      patterns << line
    else
      files << line
    end
  end

  Struct.new(:patterns, :files, :errors).new(patterns, files, errors)
end

def check_sorted(owner_entries)
  errors = []

  # We could auto-fix this, if it wasn't for comments and blank lines
  owner_entries.each_with_index.select do |entry, index|
    if index > 0 && entry.pattern <= owner_entries[index - 1].pattern
      errors << {
        code: "codeowners_file_not_in_sequence",
        message: "Line is duplicated or out of sequence at #{entry.file}:#{entry.line_number}",
        entry: entry
      }
    end
  end

  Struct.new(:errors).new(errors)
end

def check_indent(owner_entries)
  errors = []

  # We could auto-fix this
  owner_entries.each_with_index.select do |entry, index|
    if index > 0 && entry.indent != owner_entries[index - 1].indent
      errors << {
        code: "mismatched_indent",
        message: "Mismatched indent at #{entry.file}:#{entry.line_number}",
        entry: entry
      }
    end
  end

  Struct.new(:errors).new(errors)
end

def check_valid_owners(owner_entries)
  # This is just to catch typos.
  # We could look up against github, of course.
  # For now, hard-wired is better than nothing.
  valid_owners = begin
                   IO.readlines(VALIDOWNERS_PATH).map(&:chomp)
                 rescue Errno::ENOENT
                   nil
                 end

  errors = []

  if valid_owners
    owner_entries.each do |entry|
      bad_owners = entry.owners - valid_owners

      bad_owners.each do |bad_owner|
        errors << {
          code: "invalid_owner",
          message: "Invalid owner #{bad_owner} at #{entry.file}:#{entry.line_number}",
          bad_owner: bad_owner,
          entry: entry
        }
      end
    end
  end

  Struct.new(:errors).new(errors)
end

def git_ls_files(args:)
  output = `git ls-files -z #{Shellwords.shelljoin(args)}`
  $?.success? or raise "git ls-files #{args.inspect} failed"

  output.split("\0")
end

def get_all_files
  git_ls_files(args: [])
end

def find_unowned_files(owner_entries, all_files)
  unowned_files = Set.new(all_files)

  Tempfile.open do |tmpfile|
    owner_entries.each do |entry|
      tmpfile.puts entry.pattern
    end

    tmpfile.flush

    owned_files = git_ls_files(args: ["--cached", "--ignored", "--exclude-from", tmpfile.path])
    unowned_files -= owned_files
  end

  # Report on any file which is not matched by any entry (unowned)
  unowned_files.sort
end

def check_individual_patterns(owner_entries)
  # Slow but thorough: use git to check which files each individual pattern matches
  # May not scale well!

  match_map = {}
  warnings = []

  matched_files_collection = MultiGitLsRunner.new(owner_entries.map { |e| e.pattern }).run

  owner_entries.each do |entry|
    matched_files = matched_files_collection[entry.pattern]

    # Report on any pattern which doesn't match any files (cruft)
    if matched_files.empty?
      warnings << {
        code: "unmatched_pattern",
        message: "Pattern #{entry.pattern} at #{entry.file}:#{entry.line_number} doesn't match any files",
        entry: entry,
      }
    end

    matched_files.each do |file|
      (match_map[file] ||= []) << entry
    end
  end

  # Should we report on any file matched by more than one entry?
  # It could indicate an unintended conflict. But what if the
  # "conflict" is absolutely intended? Maybe it's not worth checking.
  # Maybe "too many" owners is better than too few.

  Struct.new(:match_map, :warnings).new(match_map, warnings)
end

def report_file_ownership(results, show_json, json_root_key)
  if show_json
    require 'json'
    puts JSON.pretty_generate(json_root_key => results)
  else
    results.each do |result|
      if result[:owners].any?
        puts "#{result[:file]}\t#{result[:owners].join(' ')}"
      else
        puts "#{result[:file]}\t-"
      end
    end
  end
end

def report_who_owns(owner_entries, show_json, files)
  # Discards warnings
  match_map = check_individual_patterns(owner_entries).match_map

  results = files.map do |file|
    file = file.sub(/^\.\/+/, '')
    matches = match_map[file]
    owners = if matches
      matches.map(&:owners).flatten.sort.uniq
    end
    { file: file, owners: owners || [] }
  end

  report_file_ownership(results, show_json, :who_owns)
end

def report_files_owned(owner_entries, show_json, args)
  # We don't *have* to brute force every pattern - we could instead
  # run git ls-files per owner, not per pattern. But we already have
  # the code, so it's convenient.
  match_map = if args.any?
    # Discards warnings
    check_individual_patterns(owner_entries).match_map
  else
    {}
  end

  results = get_all_files.map do |file|
    matches = match_map[file]
    next unless matches

    owners = matches.map(&:owners).flatten.sort.uniq & args
    next unless owners.any?

    { file: file, owners: owners }
  end.compact

  report_file_ownership(results, show_json, :files_owned)
end

# Warns if there are entries in the ignore file that are now owned
# Errors if there are files that don't have an owner (except if the file is included in ignore)
def check_unowned_files(unowned_files, options)
  unowned_files = Set.new(unowned_files)

  parsed = parse_unownedignore_file(options)

  warnings = []
  errors = [*parsed.errors]
  used_ignores = Set.new
  ignored_unowned = Set.new

  unowned_files.each do |unowned_file|
    if parsed.files.include?(unowned_file)
      ignored_unowned.add(unowned_file)
      used_ignores.add(unowned_file)
    end

    parsed.patterns.each do |ignore_pattern|
      if File.fnmatch?(ignore_pattern, unowned_file)
        ignored_unowned.add(unowned_file)
        used_ignores.add(ignore_pattern)
      end
    end
  end

  non_ignored_files = unowned_files - ignored_unowned
  non_ignored_files.sort.each do |file|
    errors << {
      code: "non_ignored_files",
      message: "Please add this file to #{CODEOWNERS_PATH}: #{file}", # This file does not have an owner
      unowned: file,
    }
  end

  unused_ignores = (parsed.files + parsed.patterns) - used_ignores
  unused_ignores.sort.each do |unused_ignore|
    warnings << {
      code: "unused_ignore",
      message: "The following entry in #{CODEOWNERS_IGNORE_PATH} doesn't match any unowned files and should be removed: #{unused_ignore}", # Obsolete entry
      unused_ignore: unused_ignore,
    }
  end

  Struct.new(:warnings, :errors).new(warnings, errors)
end

def run_all_checks(parse_results, owner_entries, options)
  warnings = []
  errors = []

  errors.concat(parse_results.errors)

  if options.should_check_sorted
    r = check_sorted(owner_entries)
    errors.concat(r.errors)
  end

  if options.should_check_indent
    r = check_indent(owner_entries)
    errors.concat(r.errors)
  end

  if options.should_check_valid_owners
    r = check_valid_owners(owner_entries)
    errors.concat(r.errors)
  end

  all_files = get_all_files

  if options.check_unowned
    unowned = find_unowned_files(owner_entries, all_files)
    r = check_unowned_files(unowned, options)
    warnings.concat(r.warnings)
    errors.concat(r.errors)
  end

  match_map = if options.find_redundant_ignores
                r = check_individual_patterns(owner_entries)
                warnings.concat(r.warnings)
                r.match_map
              end

  Struct.new(:errors, :warnings, :all_files, :match_map).new(errors, warnings, all_files, match_map)
end

def show_checks_json(entries, owner_entries, r, options)
  output = {
    errors: r.errors,
    warnings: r.warnings
  }

  if options.debug
    output.merge!(
      entries: entries,
      owner_entries: owner_entries,
      all_files: r.all_files,
      match_map: r.match_map,
    )
  end

  require 'json'
  puts JSON.pretty_generate(output)
end

def show_checks_text(r)
  r.errors.each { |item| puts "ERROR: #{item[:message]}" }
  r.warnings.each { |item| puts "WARNING: #{item[:message]}" }

  if r.errors.any? || r.warnings.any?
    puts "For help, see https://github.com/zendesk/setup-check-codeowners/blob/main/Usage.md"
  end
end

class GetOptions

  def initialize(argv)
    @debug = false
    @show_json = false
    @strict = false
    @find_redundant_ignores = false
    @who_owns = false
    @files_owned = false
    @check_unowned = false
    @should_check_indent = true
    @should_check_sorted = true
    @should_check_valid_owners = true
    read_options(argv)
    validate
  end

  attr_reader :debug, :show_json, :strict, :find_redundant_ignores,
    :who_owns, :files_owned,
    :check_unowned, :should_check_indent, :should_check_sorted, :should_check_valid_owners,
    :args

  private

  attr_writer :debug, :show_json, :strict, :find_redundant_ignores,
    :who_owns, :files_owned,
    :check_unowned, :should_check_indent, :should_check_sorted, :should_check_valid_owners,
    :args

  def read_options(argv)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: check-codeowners [options] [arguments]"

      opts.on("-j", "--json", "Show results as JSON") do
        self.show_json = true
      end
      opts.on("-s", "--strict", "Treat warnings as errors") do
        self.strict = true
      end
      opts.on("-b", "--brute-force", "Find entries which do not match any files") do
        self.find_redundant_ignores = true
      end
      opts.on("--no-check-indent", "Do not require equal indenting") do |value|
        self.should_check_indent = value
      end
      opts.on("--no-check-sorted", "Do not require sorted entries") do |value|
        self.should_check_sorted = value
      end
      opts.on("--no-check-valid-owners", "Do not check owners against VALIDOWNERS") do |value|
        self.should_check_valid_owners = value
      end
      opts.on(
        "--who-owns",
        "Treat arguments as a list of files; show who owns each file, then exit." \
        " If no arguments are given, all files are shown. Incompatible with" \
        " --files-owned."
      ) do
        self.who_owns = true
      end
      opts.on(
        "--files-owned",
        "Treat arguments as a list of owners; show what files they own, then exit." \
        " Incompatible with --who-owns."
      ) do
        self.files_owned = true
      end
      opts.on(
        "--check-unowned",
        "Checks if there are new files that are not owned"
      ) do
        self.check_unowned = true
      end
      opts.on("-d", "--debug", "Include debug output; implies --json") do
        self.debug = true
        self.show_json = true
      end
    end

    argv = [*argv]
    parser.parse!(argv)
    @args = argv
  end

  def validate
    if who_owns && files_owned
      $stderr.puts "Invalid usage. Try check-codeowners --help"
      exit 2
    end

    if !who_owns && !files_owned && args.any?
      $stderr.puts "Invalid usage. Try check-codeowners --help"
      exit 2
    end
  end

end

# MAIN START

options = GetOptions.new(ARGV)

parse_results = parse_codeowners_file
entries = parse_results.entries
owner_entries = entries.select { |entry| entry.is_a?(OwnerEntry) }

if options.who_owns
  files = (options.args.empty? ? get_all_files : options.args)
  report_who_owns(owner_entries, options.show_json, files)
  exit
end

if options.files_owned
  report_files_owned(owner_entries, options.show_json, options.args)
  exit
end

# CHECK MODE

r = run_all_checks(parse_results, owner_entries, options)

if options.strict
  r.errors.concat(r.warnings)
  r.warnings = []
end

if options.show_json
  show_checks_json(entries, owner_entries, r, options)
else
  show_checks_text(r)
end

exit 1 if r.errors.any?
exit 0
